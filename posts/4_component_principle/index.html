<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="stones blog.">
<title>
    4부 컴포넌트 원칙 - Call me Sam
</title>


<link rel="shortcut icon" href="/sam.ico">








<link rel="stylesheet" href="/css/main.min.c5514d3530979d291f3497facc20da1cec870028dbc2a3630b64bab8721bbe49.css" integrity="sha256-xVFNNTCXnSkfNJf6zCDaHOyHACjbwqNjC2S6uHIbvkk=" crossorigin="anonymous" media="screen">




  






<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com/tn.png"/>

<meta name="twitter:title" content="4부 컴포넌트 원칙"/>
<meta name="twitter:description" content="12. 컴포넌트&nbsp;¶ 정의
 컴포넌트는 배포단위 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위 Ex) java - jar, 루비 - gem, 닷넷 - dll, 인터프리터형 언어 - 소스 파일의 결합체, 모든 언어  컴포넌트의 간략한 역사&nbsp;¶ * 200 TLS START, CLA TAD BUFR JMS GETSTR CLA TAD BUFR JMS, .... K177,	177 MCR, -15 *200 명령어는 메모리 주소 200에 로드할 코드를 생성하라고 컴파일러에 알려준다.
재배치성&nbsp;¶ 재배치가 가능한 바이너리(relocatable binary)"/>

<meta property="og:title" content="4부 컴포넌트 원칙" />
<meta property="og:description" content="12. 컴포넌트&nbsp;¶ 정의
 컴포넌트는 배포단위 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위 Ex) java - jar, 루비 - gem, 닷넷 - dll, 인터프리터형 언어 - 소스 파일의 결합체, 모든 언어  컴포넌트의 간략한 역사&nbsp;¶ * 200 TLS START, CLA TAD BUFR JMS GETSTR CLA TAD BUFR JMS, .... K177,	177 MCR, -15 *200 명령어는 메모리 주소 200에 로드할 코드를 생성하라고 컴파일러에 알려준다.
재배치성&nbsp;¶ 재배치가 가능한 바이너리(relocatable binary)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/4_component_principle/" />
<meta property="og:image" content="https://example.com/tn.png"/>
<meta property="article:published_time" content="2019-10-21T18:34:32+00:00" />
<meta property="article:modified_time" content="2019-10-21T18:34:32+00:00" /><meta property="og:site_name" content="my name is stones" />


    

    
    
    
    <title>
        
        4부 컴포넌트 원칙
        
    </title>
</head>

<body>
    
    
    <header class="wrap flex-container">
        <h1>4부 컴포넌트 원칙</h1>
    </header>
    
    <main class="wrap">
        
<div class="flex-container">
    <aside role="complementary">
        Mon Oct 21, 2019 &#183; 795 words
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/clean-architecture/">
                    clean architecture
                </a>
            </span>
            
            
        </div>
    </aside>
    <hr />
    <article role="article">
        
<h1 id="12-컴포넌트" class="anchor-link"><a href="#12-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8">12. 컴포넌트<span class="pilcrow">&nbsp;¶</span></a></h1>
<p><strong>정의</strong></p>
<ul>
<li>컴포넌트는 배포단위</li>
<li>시스템의 구성 요소로 배포할 수 있는 가장 작은 단위</li>
<li>Ex) java - jar, 루비 - gem, 닷넷 - dll, 인터프리터형 언어 - 소스 파일의 결합체, 모든 언어</li>
</ul>

<h2 id="컴포넌트의-간략한-역사" class="anchor-link"><a href="#%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8%ec%9d%98-%ea%b0%84%eb%9e%b5%ed%95%9c-%ec%97%ad%ec%82%ac">컴포넌트의 간략한 역사<span class="pilcrow">&nbsp;¶</span></a></h2>
<pre><code class="language-pgp" data-lang="pgp">					* 200
					TLS
  START, 	CLA
  				TAD BUFR
  				JMS GETSTR
  				CLA
  				TAD BUFR
  				JMS, 
  				....
K177,			177
MCR, 			-15
</code></pre><p><code>*200</code> 명령어는 메모리 주소 200에 로드할 코드를 생성하라고 컴파일러에 알려준다.</p>

<h3 id="재배치성" class="anchor-link"><a href="#%ec%9e%ac%eb%b0%b0%ec%b9%98%ec%84%b1">재배치성<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>재배치가 가능한 바이너리(<code>relocatable binary</code>)</p>
<p>로더를 사용하여 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자.</p>
<p><!-- raw HTML omitted -->링킹로더 : 프로그램을 로드하는 동시에 링크까지 수행하는 로더<!-- raw HTML omitted --></p>

<h3 id="링커" class="anchor-link"><a href="#%eb%a7%81%ec%bb%a4">링커<span class="pilcrow">&nbsp;¶</span></a></h3>
<p><strong>1960 ~ 70년대 이후</strong></p>
<p>프로그램에 더욱 많은 기능을 넣어 프로그램이 커지자  <strong>링킹로더</strong>가 너무 느려진다.</p>
<p><em><strong><code>로드</code>, <code>링커</code> 두단계로 분리</strong></em></p>
<p>프로그래머가 느린 부분, 링크 과정을 맡어, Linker 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다.</p>
<p>링커는 링크가 완료된 재배치 코드를 만들어 주었고 , 그 덕분에 로더의 로딩 과정이 아주 빨라짐.</p>
<p><strong>1980년대</strong></p>
<p>c 와 다른 고수준 언어의 프로그램 사이즈거 더욱 커졌다.</p>
<p>Ex) 수십만 라인 이상의 큰 프로그램</p>
<p>결국 또 느려졌다.</p>

<h4 id="프로그램-크기와-관련된-머피의-법칙" class="anchor-link"><a href="#%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8-%ed%81%ac%ea%b8%b0%ec%99%80-%ea%b4%80%eb%a0%a8%eb%90%9c-%eb%a8%b8%ed%94%bc%ec%9d%98-%eb%b2%95%ec%b9%99">프로그램 크기와 관련된 머피의 법칙<span class="pilcrow">&nbsp;¶</span></a></h4>
<p><code>컴파일 하고 링크하는데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다.</code></p>

<h3 id="결론" class="anchor-link"><a href="#%ea%b2%b0%eb%a1%a0">결론<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>런타임 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이책에서 말하는 소프트웨어 컴포넌트다.</p>
<p>과거에는 초인적인 노력을 들여야 컴포넌트 플러그인 아키텍처를 적용할수 있었지만, 이제는 쉽게 사용할 수 있다.</p>

<h1 id="13장-컴포넌트-응집도" class="anchor-link"><a href="#13%ec%9e%a5-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ec%9d%91%ec%a7%91%eb%8f%84">13장. 컴포넌트 응집도<span class="pilcrow">&nbsp;¶</span></a></h1>
<ul>
<li>REP : 재사용/릴리즈 등가 원칙 (Reuse-Relese Principle)</li>
<li>CCP: 공통 폐쇄 원칙 (Common-Closure Principle)</li>
<li>CRP: 공통 재사용 원칙(Common-Reuse Principle)</li>
</ul>

<h2 id="rep-재사용릴리즈-등가-원칙" class="anchor-link"><a href="#rep-%ec%9e%ac%ec%82%ac%ec%9a%a9%eb%a6%b4%eb%a6%ac%ec%a6%88-%eb%93%b1%ea%b0%80-%ec%9b%90%ec%b9%99">REP: 재사용/릴리즈 등가 원칙<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><code>재사용의 단위는 릴리즈 단위와 같다.</code></p>
<p>릴리즈 단위 <a href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855">https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855</a></p>
<ul>
<li>패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않던지 해야한다.</li>
</ul>

<h2 id="ccp-공통-폐쇄-원칙" class="anchor-link"><a href="#ccp-%ea%b3%b5%ed%86%b5-%ed%8f%90%ec%87%84-%ec%9b%90%ec%b9%99">CCP: 공통 폐쇄 원칙<span class="pilcrow">&nbsp;¶</span></a></h2>
<blockquote>
<p>같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야한다. 패키지에 어떤 변화가 영향을 미친다면, 그 변화는 그 패키지의 모든 클래스에 영향을 미쳐야 하고 다른 패키지에는 영향을 미치치 않아야한다.</p>
</blockquote>
<p>CCP는 SRP(단일책임원칙) 을 컴포넌트 관점에서 다시 쓴것이다.</p>
<p>대부분의 애플리케이션의 유지보수성(maintainablility) 은 재사용성보다 중요하다.</p>
<p>코드가 변경이 되어야 한다면 여러 포인트의 컴퍼넌트에서 변경이 되는 것보다는 단일 컴포넌트에서 발생하는 것이 낫다. 변경을 단일 컴포넌트로 제한할 수 있다면 <strong>해당 컴포넌트</strong>만 재배포할수 있다.</p>
<p>CCP 는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을것을 권장</p>
<p>위 원칙은 OCP(개방폐쇄원칙) 과도 밀접하게 관련되어있다.</p>
<p><strong>SRP와의 유사성</strong>
<code>동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.</code></p>

<h2 id="crp-공통-재사용-원칙" class="anchor-link"><a href="#crp-%ea%b3%b5%ed%86%b5-%ec%9e%ac%ec%82%ac%ec%9a%a9-%ec%9b%90%ec%b9%99">CRP: 공통 재사용 원칙<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><code>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.</code></p>
<blockquote>
<p>패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지도 재사용해야한다.</p>
</blockquote>
<ul>
<li><strong>연관된 클래스들 끼리 묶어서 군집(패키지)을 이루게 한다.</strong></li>
<li>연관성이 낮으면 같이 묶지 않는다</li>
</ul>
<p><strong>ISP와의 관계</strong></p>
<p>CRP는 인터페이스 분리원칙의 포괄적인 버전이다.
<code>필요하지 않은 것에 의존하지 말라.</code></p>

<h3 id="컴포넌트-응집도에-대한-균형-다이어그램" class="anchor-link"><a href="#%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ec%9d%91%ec%a7%91%eb%8f%84%ec%97%90-%eb%8c%80%ed%95%9c-%ea%b7%a0%ed%98%95-%eb%8b%a4%ec%9d%b4%ec%96%b4%ea%b7%b8%eb%9e%a8">컴포넌트 응집도에 대한 균형 다이어그램<span class="pilcrow">&nbsp;¶</span></a></h3>
<p><!-- raw HTML omitted --></p>

<h3 id="ccp-vs-crp" class="anchor-link"><a href="#ccp-vs-crp">CCP vs CRP<span class="pilcrow">&nbsp;¶</span></a></h3>
<ul>
<li>CCP를 확대하면 CRP가 축소 : 전체 패키지 수가 줄어듬 : 개발 용이성</li>
<li>CRP를 확대하면 CCP가 축소 : 전체 패키지 수가 늘어남 : 재사용성</li>
<li>서로 <strong>상충</strong></li>
<li>ISSUE 따라서 패키지 구성은 개발 용이성 -&gt; 재사용성 으로 옮겨가면서 진화한다.</li>
</ul>

<h1 id="14-컴포넌트-결합" class="anchor-link"><a href="#14-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ea%b2%b0%ed%95%a9">14. 컴포넌트 결합<span class="pilcrow">&nbsp;¶</span></a></h1>

<h2 id="adp--의존성-비순환-원칙acycleic-dependencies-principle" class="anchor-link"><a href="#adp--%ec%9d%98%ec%a1%b4%ec%84%b1-%eb%b9%84%ec%88%9c%ed%99%98-%ec%9b%90%ec%b9%99acycleic-dependencies-principle">ADP : 의존성 비순환 원칙(Acycleic-Dependencies Principle)<span class="pilcrow">&nbsp;¶</span></a></h2>
<blockquote>
<p>컴포넌트 의존성 그래프에 순환이 있어서는 안된다.</p>
</blockquote>

<h3 id="주간-빌드" class="anchor-link"><a href="#%ec%a3%bc%ea%b0%84-%eb%b9%8c%eb%93%9c">주간 빌드<span class="pilcrow">&nbsp;¶</span></a></h3>
<ul>
<li>
<p>주 4일 작업  + 주 1일  통합 빌드.</p>
</li>
<li>
<p>프로젝트가 커지며 위 복잡도가 커짐.</p>
<ul>
<li>마지막 빌드 시간이 점점 길어져 하루에 끝나지 않음</li>
<li>빌드를 격주로 하자라는 말이 나옴.</li>
</ul>
</li>
</ul>

<h3 id="순환-의존성-제거하기" class="anchor-link"><a href="#%ec%88%9c%ed%99%98-%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%a0%9c%ea%b1%b0%ed%95%98%ea%b8%b0">순환 의존성 제거하기<span class="pilcrow">&nbsp;¶</span></a></h3>

<h5 id="해결책" class="anchor-link"><a href="#%ed%95%b4%ea%b2%b0%ec%b1%85">해결책<span class="pilcrow">&nbsp;¶</span></a></h5>
<p>개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것.</p>
<p><!-- raw HTML omitted --></p>
<p>위 구조는 비순환 방향 그래프</p>
<p>마지막 빌드 과정</p>
<p>Entities -&gt; Database , Interactors -&gt; Presenters, View, Controllers, Authorizer -&gt; main</p>

<h4 id="순환이-컴포넌트-의존성-그래프에-미치는-영향" class="anchor-link"><a href="#%ec%88%9c%ed%99%98%ec%9d%b4-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ec%9d%98%ec%a1%b4%ec%84%b1-%ea%b7%b8%eb%9e%98%ed%94%84%ec%97%90-%eb%af%b8%ec%b9%98%eb%8a%94-%ec%98%81%ed%96%a5">순환이 컴포넌트 의존성 그래프에 미치는 영향<span class="pilcrow">&nbsp;¶</span></a></h4>
<p><!-- raw HTML omitted --></p>
<ul>
<li>Database -&gt; Entities -&gt; Authorizer -&gt; Interactor 순으로 순환고리가 이어져 하나의 거대한 컴포넌트가 되어짐.</li>
</ul>

<h4 id="순환-끊기" class="anchor-link"><a href="#%ec%88%9c%ed%99%98-%eb%81%8a%ea%b8%b0">순환 끊기<span class="pilcrow">&nbsp;¶</span></a></h4>
<ol>
<li>DIP(의존성 역전원칙) 적용.</li>
<li>Entities 와 Autorizer가 모두 의존하는 새 컴퍼넌트를 만든다.</li>
</ol>

<h4 id="흐트러짐jitters" class="anchor-link"><a href="#%ed%9d%90%ed%8a%b8%eb%9f%ac%ec%a7%90jitters">흐트러짐(Jitters)<span class="pilcrow">&nbsp;¶</span></a></h4>
<p>요구사항이 변경되면 컴포넌트 구조도 변경될수 있다는 사실.</p>
<p>어플리케이션이 성장함에 따라 의존성 구조는 점점 흐트러지고 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야한다. 순환이 발생하면 어떤 식으로든 끊어야 한다.</p>

<h2 id="하향식설계top-down" class="anchor-link"><a href="#%ed%95%98%ed%96%a5%ec%8b%9d%ec%84%a4%ea%b3%84top-down">하향식설계(top-down)<span class="pilcrow">&nbsp;¶</span></a></h2>
<ul>
<li>패키지 구조를 먼저 설계하면 실패할 가능성이 크다.</li>
<li>패키지 의존 관계 구조는 시스템의 논리적 설계와 함께 진화해야 한다</li>
</ul>

<h2 id="sdp-안정된-의존성-원칙stable-dependencies-principle" class="anchor-link"><a href="#sdp-%ec%95%88%ec%a0%95%eb%90%9c-%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%9b%90%ec%b9%99stable-dependencies-principle">SDP: 안정된 의존성 원칙(Stable-Dependencies Principle)<span class="pilcrow">&nbsp;¶</span></a></h2>
<blockquote>
<p>안정성의 방향으로(더 안정된 쪽에) 의존하라.</p>
</blockquote>
<ul>
<li>SDP가 적용된 패키지는 쉽게 변화도록 설계가 되어 있어서 <strong>변경되리라 예상할 수 있다.</strong></li>
</ul>

<h3 id="안정성" class="anchor-link"><a href="#%ec%95%88%ec%a0%95%ec%84%b1">안정성<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>안정성은 변화를 만들기 위해 필요한 작업량</p>
<p><strong>안정된 컴포넌트</strong>
<!-- raw HTML omitted --></p>
<p>X는 안정적이다. 세 컴포넌트가 X에 의존하며 , 따라서 X는 변경하지 말아야 할 이유가 세가지나 되지 때문이다. 이 경우 X는 세 컴포넌트를 책임진다(responsible)라고 말한다. 반대로 X는 어디에도 의존하지 않으므로 X는 독립적이다.(independent)라고 말한다.</p>
<p><strong>불안정한 컴포넌트</strong>
<!-- raw HTML omitted --></p>
<ul>
<li>Y는 3개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부요인이 3가지다.</li>
<li>Y는 의존적이다.</li>
</ul>

<h3 id="안정성-지표" class="anchor-link"><a href="#%ec%95%88%ec%a0%95%ec%84%b1-%ec%a7%80%ed%91%9c">안정성 지표<span class="pilcrow">&nbsp;¶</span></a></h3>
<ul>
<li>fan-in: 안으로 들어오는 의존성.</li>
<li>Fan-out: 밖으로 나가는 의존성.</li>
<li>I(불안정성): I = Fan-out / (Fan-in + Fan-out). I=0 이면 최고로 안정된 컴포넌트라는 뜻, I=1 이면 최고로 불안정한 컴포넌트라는 뜻.</li>
</ul>

<h3 id="모든-컴퍼넌트가-안정적이어야-하는-것은-아니다" class="anchor-link"><a href="#%eb%aa%a8%eb%93%a0-%ec%bb%b4%ed%8d%bc%eb%84%8c%ed%8a%b8%ea%b0%80-%ec%95%88%ec%a0%95%ec%a0%81%ec%9d%b4%ec%96%b4%ec%95%bc-%ed%95%98%eb%8a%94-%ea%b2%83%ec%9d%80-%ec%95%84%eb%8b%88%eb%8b%a4">모든 컴퍼넌트가 안정적이어야 하는 것은 아니다.<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>만약 모든 패키지가 안정적이라면 시스템은 변경할 수 없게 될 것이다.
공통패키지를 이용 불안정성을 유지해서 확장가능하게 한다.</p>

<h2 id="sap--안정된-추상화-원칙stable-abstractions-principle" class="anchor-link"><a href="#sap--%ec%95%88%ec%a0%95%eb%90%9c-%ec%b6%94%ec%83%81%ed%99%94-%ec%9b%90%ec%b9%99stable-abstractions-principle">SAP : 안정된 추상화 원칙(Stable-Abstractions Principle)<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><code>컴포넌트는 안정된 정도만큼만 추상화되어야한다.</code></p>
<p>안정성과 추상성 사이의 관계를 정한다.</p>
<p>추상클래스(인터페이스)를 통해서 추상성과 안정성 사이의 균형을 확보
패키지의 성격에 따라 적절한 추상성을 확보해야한다.</p>
<p>SAP와 SDP 를 결합하면 컴포넌트에 대한 DIP 와 비슷하다.
컴포넌트는 어느 부분은 추상적이면서 다른 부분은 안정적일 수 있다.</p>

<h4 id="주계열" class="anchor-link"><a href="#%ec%a3%bc%ea%b3%84%ec%97%b4">주계열<span class="pilcrow">&nbsp;¶</span></a></h4>
<ul>
<li>A: 추상화 정도</li>
<li>I: 불안정성</li>
</ul>
<p><!-- raw HTML omitted --></p>
<ul>
<li>0,0 : 안정적이고 구체적</li>
<li>1,1: 의존성이 없고(불안정적)추상적 : 쓸모없는 구역</li>
<li>1,0 &amp; 0,1 : 주계열 , 너무 추상적이지 않고 안정적이지도 않음.</li>
</ul>

    </article>
</div>


        
<nav role="navigation" class="flex-container bottom-menu">
    
<hr />
<p>


    
        <a href="/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="/posts">posts</a>
        
    
    
        
            &#183; 
            <a href="/gallery">gallery</a>
        
            &#183; 
            <a href="/portfolio">portfolio</a>
        
            &#183; 
            <a href="/about">who is stones?</a>
        
    
    &#183; 
    <a href="/">
        main
    </a>

</p>
</nav>

    </main>
    
    <footer class="flex-container footer">
</footer>
    
    
</body>

</html>