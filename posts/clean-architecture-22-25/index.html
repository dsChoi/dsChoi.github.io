<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="stones blog.">
<title>
    5부 아키텍처 22장 ~ 25장 - my name is Stones
</title>


<link rel="shortcut icon" href="/sam.ico">








<link rel="stylesheet" href="/css/main.min.c5514d3530979d291f3497facc20da1cec870028dbc2a3630b64bab8721bbe49.css" integrity="sha256-xVFNNTCXnSkfNJf6zCDaHOyHACjbwqNjC2S6uHIbvkk=" crossorigin="anonymous" media="screen">




  






<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com/tn.png"/>

<meta name="twitter:title" content="5부 아키텍처 22장 ~ 25장"/>
<meta name="twitter:description" content="22장 클린아키텍처&nbsp;¶ 시스템 아키텍처와 관련된 여러가지 아이디어
 육각형 아키텍처 (Hexagonal Architecture) DCI(Data Context and Interaction) BCE (Boundary-Control-Entity)  위 아키텍처의 목표?
 관심사의 분리  소프트웨어를 계층으로 분리함으로써 관심사의 분리 목표를 달성 최소한 업무 규칙을 위한 계층과, 사용자와 시스템인터페이스를 위한 또 다른 계층 하나를 포함해야한다.    특성
 프레임워크 독립성 테스트 용이성 UI 독립성 데이터베이스 독립성 모든 외부 에이전시에 대한 독립성   참고 : https://medium.com/@erish/python-django-clean-architecture-%EC%97%B0%EA%B5%AC%ED%95%98%EA%B8%B0-591d7a555059  의존성 규칙&nbsp;¶  소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다."/>

<meta property="og:title" content="5부 아키텍처 22장 ~ 25장" />
<meta property="og:description" content="22장 클린아키텍처&nbsp;¶ 시스템 아키텍처와 관련된 여러가지 아이디어
 육각형 아키텍처 (Hexagonal Architecture) DCI(Data Context and Interaction) BCE (Boundary-Control-Entity)  위 아키텍처의 목표?
 관심사의 분리  소프트웨어를 계층으로 분리함으로써 관심사의 분리 목표를 달성 최소한 업무 규칙을 위한 계층과, 사용자와 시스템인터페이스를 위한 또 다른 계층 하나를 포함해야한다.    특성
 프레임워크 독립성 테스트 용이성 UI 독립성 데이터베이스 독립성 모든 외부 에이전시에 대한 독립성   참고 : https://medium.com/@erish/python-django-clean-architecture-%EC%97%B0%EA%B5%AC%ED%95%98%EA%B8%B0-591d7a555059  의존성 규칙&nbsp;¶  소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/clean-architecture-22-25/" />
<meta property="og:image" content="https://example.com/tn.png"/>
<meta property="article:published_time" content="2019-11-11T20:11:19+00:00" />
<meta property="article:modified_time" content="2019-11-11T20:11:19+00:00" /><meta property="og:site_name" content="my name is stones" />


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-XR2Y95VWMZ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


    

    
    
    
    <title>
        
        5부 아키텍처 22장 ~ 25장
        
    </title>
</head>

<body>
    
    
    <header class="wrap flex-container">
        <h1>5부 아키텍처 22장 ~ 25장</h1>
    </header>
    
    <main class="wrap">
        
<div class="flex-container">
    <aside role="complementary">
        Mon Nov 11, 2019 &#183; 786 words
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/clean-architecture/">
                    clean architecture
                </a>
            </span>
            
            
        </div>
    </aside>
    <hr />
    <article role="article">
        
<h1 id="22장-클린아키텍처" class="anchor-link"><a href="#22%ec%9e%a5-%ed%81%b4%eb%a6%b0%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98">22장 클린아키텍처<span class="pilcrow">&nbsp;¶</span></a></h1>
<p><strong>시스템 아키텍처와 관련된 여러가지 아이디어</strong></p>
<ul>
<li>육각형 아키텍처 (Hexagonal Architecture)</li>
<li>DCI(Data Context and Interaction)</li>
<li>BCE (Boundary-Control-Entity)</li>
</ul>
<p><strong>위 아키텍처의 목표?</strong></p>
<ul>
<li>관심사의 분리
<ul>
<li>소프트웨어를 계층으로 분리함으로써 관심사의 분리 목표를 달성</li>
<li>최소한 업무 규칙을 위한 계층과, 사용자와 시스템인터페이스를 위한 또 다른 계층 하나를 포함해야한다.</li>
</ul>
</li>
</ul>
<p><strong>특성</strong></p>
<ul>
<li>프레임워크 독립성</li>
<li>테스트 용이성</li>
<li>UI 독립성</li>
<li>데이터베이스 독립성</li>
<li>모든 외부 에이전시에 대한 독립성</li>
</ul>
<p><!-- raw HTML omitted --></p>
<ul>
<li>참고 :    <a href="https://medium.com/@erish/python-django-clean-architecture-%EC%97%B0%EA%B5%AC%ED%95%98%EA%B8%B0-591d7a555059">https://medium.com/@erish/python-django-clean-architecture-%EC%97%B0%EA%B5%AC%ED%95%98%EA%B8%B0-591d7a555059</a></li>
</ul>

<h2 id="의존성-규칙" class="anchor-link"><a href="#%ec%9d%98%ec%a1%b4%ec%84%b1-%ea%b7%9c%ec%b9%99">의존성 규칙<span class="pilcrow">&nbsp;¶</span></a></h2>
<blockquote>
<p>소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.</p>
</blockquote>
<ul>
<li>내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.</li>
<li>외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안된다.</li>
</ul>

<h3 id="엔티티" class="anchor-link"><a href="#%ec%97%94%ed%8b%b0%ed%8b%b0">엔티티<span class="pilcrow">&nbsp;¶</span></a></h3>
<blockquote>
<p>전사적인 핵심 업무 규칙을 캡슐화 한것</p>
</blockquote>
<p>메서드를 가지는 객체이거나 데이터 구조와 함수의 집합일수도 있다.</p>
<p>외부의 무엇인가가 변경되더라도 엔티티가 변경될 가능성은 적다.</p>
<p>특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다.</p>

<h3 id="유스케이스" class="anchor-link"><a href="#%ec%9c%a0%ec%8a%a4%ec%bc%80%ec%9d%b4%ec%8a%a4">유스케이스<span class="pilcrow">&nbsp;¶</span></a></h3>
<blockquote>
<p>애플리케이션에 특화된 업무 규칙을 포함</p>
</blockquote>
<p>시스템의 모든 유스케이스를 캡슐화 하고 구현</p>
<p>엔티티로 들어오고 나가는 데이터 흐름을 조정</p>
<p>유스케이스에서 발생한 변경이 엔티티에 영향을 줘서는 안된다.</p>

<h3 id="인터페이스-어댑터interface-adaptor" class="anchor-link"><a href="#%ec%9d%b8%ed%84%b0%ed%8e%98%ec%9d%b4%ec%8a%a4-%ec%96%b4%eb%8c%91%ed%84%b0interface-adaptor">인터페이스 어댑터(Interface Adaptor)<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>일련의 어댑터들로 구성</p>
<p>프레젠터, 뷰, 컨트롤러는 인터페이스 어댑터 계층에 속한다.</p>
<p>데이터를 엔티티나 유스케이스형식에서 영속성용으로 사용중인 임의의 프레임워크(데이터베이스)가 이용하기 편리한 형식으로 변환한다.</p>
<p>데이터베이스에 대해 알아서는 안된다.</p>

<h3 id="프레임워크와-드라이버" class="anchor-link"><a href="#%ed%94%84%eb%a0%88%ec%9e%84%ec%9b%8c%ed%81%ac%ec%99%80-%eb%93%9c%eb%9d%bc%ec%9d%b4%eb%b2%84">프레임워크와 드라이버<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>이 계층에서는 안쪽원과 통신하기 위한 접합 코드 외에는 특별히 더 작성할 코드가 많지 않다.</p>
<p>모든 세부사항이 위치하는 곳</p>
<p><strong>세부사항</strong></p>
<ul>
<li>웹</li>
<li>데이터베이스</li>
</ul>
<blockquote>
<p>세부사항을 외부에 위치시켜서 피해를 최소화해야함.</p>
</blockquote>

<h3 id="원은-네-개여야만-하나" class="anchor-link"><a href="#%ec%9b%90%ec%9d%80-%eb%84%a4-%ea%b0%9c%ec%97%ac%ec%95%bc%eb%a7%8c-%ed%95%98%eb%82%98">원은 네 개여야만 하나?<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>위 네개의 원은 개념을 설명하기 위한 예시일뿐 더 많은 원이 필요할 수 있다.</p>
<p>하지만 <code>의존성 규칙</code> 은 적용되어야한다.</p>
<ul>
<li>
<p>소스코드 의존성은 항상 안쪽을 향한다.</p>
</li>
<li>
<p>안족으로 이동할수록 추상화와 정책의 수준은 높아진다.</p>
</li>
<li>
<p>가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.</p>
</li>
</ul>
<blockquote>
<p>안쪽으로 이동할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.</p>
</blockquote>
<p><strong>가장 안쪽 원</strong></p>
<p>가장 범용적이며 높은 수준을 가진다.</p>

<h3 id="경계-횡단하기" class="anchor-link"><a href="#%ea%b2%bd%ea%b3%84-%ed%9a%a1%eb%8b%a8%ed%95%98%ea%b8%b0">경계 횡단하기<span class="pilcrow">&nbsp;¶</span></a></h3>
<p><p style="text-align:center;">
    <img src="./clean-architecture-22-25/image-20191111224420543.png" alt="image-20191111224420543"  />
</p>
</p>
<p>컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 예제</p>
<p><strong>제어 흐름</strong></p>
<p>컨트롤러 -&gt; 유스케이스 -&gt; 프레젠터</p>
<p><strong>의존성</strong></p>
<ul>
<li>
<p>컨트롤러 -&gt; 유스케이스</p>
</li>
<li>
<p>프레젠터 -&gt; 유스케이스</p>
</li>
</ul>
<p><strong>의존성 역전원칙</strong></p>
<p>제어흐름과 의존성의 방향이 반대여야하나는 경우</p>
<p><strong>아키텍처 경계횡단시</strong></p>
<p>동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.</p>

<h3 id="경계를-횡단하는-데이터는-어떤-모습인가" class="anchor-link"><a href="#%ea%b2%bd%ea%b3%84%eb%a5%bc-%ed%9a%a1%eb%8b%a8%ed%95%98%eb%8a%94-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%8a%94-%ec%96%b4%eb%96%a4-%eb%aa%a8%ec%8a%b5%ec%9d%b8%ea%b0%80">경계를 횡단하는 데이터는 어떤 모습인가?<span class="pilcrow">&nbsp;¶</span></a></h3>
<ul>
<li>기본적인 구조체</li>
<li>데이터 전송 객체(Data Transfer Object)</li>
<li>간단한 인자</li>
<li>해시맵</li>
</ul>
<p><strong>중요한 점</strong></p>
<p>격리되어 있는 데이터 구조가 경계를 가로질러 전달된다는 점</p>
<p>경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야한다.</p>

<h2 id="전형적인-시나리오" class="anchor-link"><a href="#%ec%a0%84%ed%98%95%ec%a0%81%ec%9d%b8-%ec%8b%9c%eb%82%98%eb%a6%ac%ec%98%a4">전형적인 시나리오<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><p style="text-align:center;">
    <img src="./clean-architecture-22-25/image-20191111230636691.png" alt="image-20191111230636691"  />
</p>
</p>

<h2 id="결론" class="anchor-link"><a href="#%ea%b2%b0%eb%a1%a0">결론<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다. 데이터베이스나 웹 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할수 있다.</p>

<h1 id="23장-프레전터와-험블-객체" class="anchor-link"><a href="#23%ec%9e%a5-%ed%94%84%eb%a0%88%ec%a0%84%ed%84%b0%ec%99%80-%ed%97%98%eb%b8%94-%ea%b0%9d%ec%b2%b4">23장 프레전터와 험블 객체<span class="pilcrow">&nbsp;¶</span></a></h1>

<h2 id="험블객체-패턴" class="anchor-link"><a href="#%ed%97%98%eb%b8%94%ea%b0%9d%ec%b2%b4-%ed%8c%a8%ed%84%b4">험블객체 패턴<span class="pilcrow">&nbsp;¶</span></a></h2>
<blockquote>
<p>테스트 하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법</p>
</blockquote>
<p><strong>험블 객체 패턴</strong></p>
<ol>
<li>
<p>행위들을 두 개의 모듈로 분리.</p>
</li>
<li>
<p>둘 중 하나가 험블이다.</p>
</li>
<li>
<p>가장 기본적인 본질은 남기고 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다.</p>
</li>
</ol>

<h2 id="프레젠터와-뷰" class="anchor-link"><a href="#%ed%94%84%eb%a0%88%ec%a0%a0%ed%84%b0%ec%99%80-%eb%b7%b0">프레젠터와 뷰<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><strong>뷰</strong></p>
<blockquote>
<p>험블 객체이고 테스트하기 어렵다.</p>
</blockquote>
<p><strong>프레젠터</strong></p>
<blockquote>
<p>애플리케이션으로부터 데이터를 받아 화면에 표시할 수 있는 포맷으로 만드는 것</p>
</blockquote>

<h2 id="테스트와-아키텍처" class="anchor-link"><a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%99%80-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98">테스트와 아키텍처<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>테스트 용이성은 좋은 아키텍처가 지녀야 할 속성.</p>
<p>험블 객체 패턴이 좋은 예</p>
<p>행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의되기 때문이다.</p>
<p>프레젠터와 뷰 사이의 경계가 이러한 경계중 하나이다.</p>

<h2 id="데이터베이스-게이트웨이" class="anchor-link"><a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ea%b2%8c%ec%9d%b4%ed%8a%b8%ec%9b%a8%ec%9d%b4">데이터베이스 게이트웨이<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>유스케이스 계층과 데ㅣ터베이스 사이에 데이터 베이스 게이트웨이가 존재.</p>
<p>데이터베이스 게이트웨이트</p>
<ul>
<li>다형적 인터페이스</li>
<li>애플리케이션이 데이터 베이스에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메서드를 포함.</li>
</ul>
<p>데이터베이스 게이트웨이 인터페이스 구현체 는 데이터베이스 계층에 위치하고 이 구현체는 험블객체이다.</p>

<h2 id="데이터-매퍼" class="anchor-link"><a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%a7%a4%ed%8d%bc">데이터 매퍼<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>객체 관계매퍼는 존재하지 않는다.</p>
<p>객체는 단순히 오퍼레이션의 집합이다.</p>
<p>ORM 보다는 데이터 매퍼라 부른게 맞다.</p>
<p>ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 험블 객체 경계를 형성한다.</p>

<h2 id="서비스-리스너" class="anchor-link"><a href="#%ec%84%9c%eb%b9%84%ec%8a%a4-%eb%a6%ac%ec%8a%a4%eb%84%88">서비스 리스너<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>서비스 리스너는 서비스 인터페이스로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할수 있게 간단한 데이터 구조로 포맷을 변경한다. 그 후 데이터 구조는 서비스 경계를 가로질러서 내부로 전달된다.</p>

<h2 id="결론-1" class="anchor-link"><a href="#%ea%b2%b0%eb%a1%a0-1">결론<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>각 아키텍처 경계마다 경계 가까이 있는 험블 객체 패턴을 발견할수 있었다.</p>
<ul>
<li>프레젠터</li>
<li>데이터베이스 게이트웨이 인터페이스 구현체</li>
<li>ORM</li>
</ul>
<p>아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일수 있다.</p>

<h1 id="24장-부분적-경계" class="anchor-link"><a href="#24%ec%9e%a5-%eb%b6%80%eb%b6%84%ec%a0%81-%ea%b2%bd%ea%b3%84">24장 부분적 경계<span class="pilcrow">&nbsp;¶</span></a></h1>
<p><strong>YAGNI</strong> (You Aren&rsquo;t Going to Need It)</p>
<blockquote>
<p>너는 그게 필요하지 않아!  -&raquo; &ldquo;필요한 작업만 해라&rdquo;</p>
</blockquote>
<p>##부분적 경계</p>

<h3 id="마지막-단계를-건너뛰기" class="anchor-link"><a href="#%eb%a7%88%ec%a7%80%eb%a7%89-%eb%8b%a8%ea%b3%84%eb%a5%bc-%ea%b1%b4%eb%84%88%eb%9b%b0%ea%b8%b0">마지막 단계를 건너뛰기<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행 후, 단일 컴포넌트로 모아만 두는 것.</p>
<p><strong>장점</strong></p>
<ul>
<li>다수의 컴포넌트를 관리하는 작업이 필요없다.</li>
<li>버전 번호도 필요없다.</li>
<li>배포 관리 부담도 없다.</li>
</ul>
<p><strong>단점</strong></p>
<blockquote>
<p>완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다.</p>
</blockquote>

<h3 id="일차원-경계" class="anchor-link"><a href="#%ec%9d%bc%ec%b0%a8%ec%9b%90-%ea%b2%bd%ea%b3%84">일차원 경계<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>전략패턴</p>
<p><!-- raw HTML omitted --></p>

<h3 id="퍼사드" class="anchor-link"><a href="#%ed%8d%bc%ec%82%ac%eb%93%9c">퍼사드<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>퍼사드 패턴</p>
<p><!-- raw HTML omitted --></p>

<h2 id="결론-2" class="anchor-link"><a href="#%ea%b2%b0%eb%a1%a0-2">결론<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>부분적 경계 세가지 방법들은 나름의 비용과 장점을 지닌다.</p>
<p>각 접근법은 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 서로 다르다..</p>
<p>아키텍처 경계가 언제, 어디에 존재해야 할지 , 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역활이다.</p>

<h1 id="25장-계층과-경계" class="anchor-link"><a href="#25%ec%9e%a5-%ea%b3%84%ec%b8%b5%ea%b3%bc-%ea%b2%bd%ea%b3%84">25장 계층과 경계<span class="pilcrow">&nbsp;¶</span></a></h1>

<h2 id="움퍼스-사냥-게임" class="anchor-link"><a href="#%ec%9b%80%ed%8d%bc%ec%8a%a4-%ec%82%ac%eb%83%a5-%ea%b2%8c%ec%9e%84">움퍼스 사냥 게임<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted --></p>

<h2 id="클린-아키텍처" class="anchor-link"><a href="#%ed%81%b4%eb%a6%b0-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98">클린 아키텍처?<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><strong>개선된 다이어그램</strong></p>
<p><!-- raw HTML omitted --></p>
<p><strong>단순화된 다이어그램</strong></p>
<p><!-- raw HTML omitted --></p>

<h2 id="흐름-횡단하기" class="anchor-link"><a href="#%ed%9d%90%eb%a6%84-%ed%9a%a1%eb%8b%a8%ed%95%98%ea%b8%b0">흐름 횡단하기<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><strong>흐름 횡단하기</strong></p>
<p><!-- raw HTML omitted --></p>

<h2 id="흐름-분리하기" class="anchor-link"><a href="#%ed%9d%90%eb%a6%84-%eb%b6%84%eb%a6%ac%ed%95%98%ea%b8%b0">흐름 분리하기<span class="pilcrow">&nbsp;¶</span></a></h2>
<p><!-- raw HTML omitted --></p>
<p><strong>마이크로서비스 api 추가하기</strong></p>
<p><!-- raw HTML omitted --></p>

<h2 id="결론-3" class="anchor-link"><a href="#%ea%b2%b0%eb%a1%a0-3">결론<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>아키텍처 경계는 어디에나 존재한다.</p>
<p>경계를 제대로 구현하려면 비용이 많이든다.</p>
<p>경계가 무시되고 나중에 다시 추가하려면 추가비용이 크다.</p>
<p>추상화가 필요하다고 미리 예측해서는 안된다. (YAGNI)</p>
<p><code>오버 엔지니어링이 언더 엔지니어링보다 나쁠때가 훨씬 많다.</code></p>
<p><strong>목표</strong></p>
<p>경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현하는 것</p>

    </article>
</div>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "XYW" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


        
<nav role="navigation" class="flex-container bottom-menu">
    
<hr />
<p>


    
        <a href="/posts">back</a>
        
            &#183;
        
    

    
        
            <a href="/posts">posts</a>
        
    
    
        
            &#183; 
            <a href="/gallery">gallery</a>
        
            &#183; 
            <a href="/portfolio">portfolio</a>
        
            &#183; 
            <a href="/about">who is stones?</a>
        
    
    &#183; 
    <a href="/">
        main
    </a>

</p>
</nav>

    </main>
    
    <footer class="flex-container footer">
</footer>
    
    
</body>

</html>