---
title: 4부 컴포넌트 원칙
date: 2019-10-21 18:34:32
categories: 도서
tags:
- clean architecture
---



# 12. 컴포넌트

**정의**

* 컴포넌트는 배포단위
* 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위
* Ex) java - jar, 루비 - gem, 닷넷 - dll, 인터프리터형 언어 - 소스 파일의 결합체, 모든 언어 

## 컴포넌트의 간략한 역사

```pgp
					* 200
					TLS
  START, 	CLA
  				TAD BUFR
  				JMS GETSTR
  				CLA
  				TAD BUFR
  				JMS, 
  				....
K177,			177
MCR, 			-15
```

 `*200` 명령어는 메모리 주소 200에 로드할 코드를 생성하라고 컴파일러에 알려준다.





### 재배치성

재배치가 가능한 바이너리(`relocatable binary`)

로더를 사용하여 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자.

<u>링킹로더 : 프로그램을 로드하는 동시에 링크까지 수행하는 로더</u>




### 링커

**1960 ~ 70년대 이후**

 프로그램에 더욱 많은 기능을 넣어 프로그램이 커지자  **링킹로더**가 너무 느려진다. 



***`로드`, `링커` 두단계로 분리***

프로그래머가 느린 부분, 링크 과정을 맡어, Linker 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다.

링커는 링크가 완료된 재배치 코드를 만들어 주었고 , 그 덕분에 로더의 로딩 과정이 아주 빨라짐.



**1980년대**  

c 와 다른 고수준 언어의 프로그램 사이즈거 더욱 커졌다.

Ex) 수십만 라인 이상의 큰 프로그램

결국 또 느려졌다. 



#### 프로그램 크기와 관련된 머피의 법칙

`컴파일 하고 링크하는데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다.`



### 결론

런타임 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이책에서 말하는 소프트웨어 컴포넌트다.

과거에는 초인적인 노력을 들여야 컴포넌트 플러그인 아키텍처를 적용할수 있었지만, 이제는 쉽게 사용할 수 있다.



# 13장. 컴포넌트 응집도

* REP : 재사용/릴리즈 등가 원칙 (Reuse-Relese Principle)
* CCP: 공통 폐쇄 원칙 (Common-Closure Principle)
* CRP: 공통 재사용 원칙(Common-Reuse Principle)


## REP: 재사용/릴리즈 등가 원칙
`재사용의 단위는 릴리즈 단위와 같다.`

릴리즈 단위 https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855

* 패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않던지 해야한다.


## CCP: 공통 폐쇄 원칙
> 같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야한다. 패키지에 어떤 변화가 영향을 미친다면, 그 변화는 그 패키지의 모든 클래스에 영향을 미쳐야 하고 다른 패키지에는 영향을 미치치 않아야한다.

CCP는 SRP(단일책임원칙) 을 컴포넌트 관점에서 다시 쓴것이다. 

대부분의 애플리케이션의 유지보수성(maintainablility) 은 재사용성보다 중요하다.

코드가 변경이 되어야 한다면 여러 포인트의 컴퍼넌트에서 변경이 되는 것보다는 단일 컴포넌트에서 발생하는 것이 낫다. 변경을 단일 컴포넌트로 제한할 수 있다면 **해당 컴포넌트**만 재배포할수 있다.

CCP 는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을것을 권장

위 원칙은 OCP(개방폐쇄원칙) 과도 밀접하게 관련되어있다. 

**SRP와의 유사성**
`동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.`

## CRP: 공통 재사용 원칙
`컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.`
> 패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지도 재사용해야한다.

- **연관된 클래스들 끼리 묶어서 군집(패키지)을 이루게 한다.**
- 연관성이 낮으면 같이 묶지 않는다

**ISP와의 관계**

CRP는 인터페이스 분리원칙의 포괄적인 버전이다. 
`필요하지 않은 것에 의존하지 말라.`



### 컴포넌트 응집도에 대한 균형 다이어그램

<img src="./4_component_principle/13_1.png" alt="13.1결합도 원칙들의 균형 다이어그램" style="zoom:20%;" />

### CCP vs CRP

- CCP를 확대하면 CRP가 축소 : 전체 패키지 수가 줄어듬 : 개발 용이성
- CRP를 확대하면 CCP가 축소 : 전체 패키지 수가 늘어남 : 재사용성
- 서로 **상충**
- ISSUE 따라서 패키지 구성은 개발 용이성 -> 재사용성 으로 옮겨가면서 진화한다. 





# 14. 컴포넌트 결합

## ADP : 의존성 비순환 원칙(Acycleic-Dependencies Principle)

> 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.



### 주간 빌드

* 주 4일 작업  + 주 1일  통합 빌드. 

* 프로젝트가 커지며 위 복잡도가 커짐.
  * 마지막 빌드 시간이 점점 길어져 하루에 끝나지 않음
  * 빌드를 격주로 하자라는 말이 나옴.

### 순환 의존성 제거하기

##### 해결책 

개발 환경을 릴리즈 가능한 컴포넌트 단위로 분리하는 것. 



<img src="./4_component_principle/image-20191023225916783.png" style="zoom:50%;" />

위 구조는 비순환 방향 그래프



마지막 빌드 과정 

Entities -> Database , Interactors -> Presenters, View, Controllers, Authorizer -> main



#### 순환이 컴포넌트 의존성 그래프에 미치는 영향

<img src="./4_component_principle/image-20191023225931530.png" style="zoom:50%;" />


* Database -> Entities -> Authorizer -> Interactor 순으로 순환고리가 이어져 하나의 거대한 컴포넌트가 되어짐.

#### 순환 끊기

1. DIP(의존성 역전원칙) 적용.
2. Entities 와 Autorizer가 모두 의존하는 새 컴퍼넌트를 만든다.



#### 흐트러짐(Jitters)

요구사항이 변경되면 컴포넌트 구조도 변경될수 있다는 사실.

어플리케이션이 성장함에 따라 의존성 구조는 점점 흐트러지고 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야한다. 순환이 발생하면 어떤 식으로든 끊어야 한다. 





## 하향식설계(top-down)



- 패키지 구조를 먼저 설계하면 실패할 가능성이 크다.
- 패키지 의존 관계 구조는 시스템의 논리적 설계와 함께 진화해야 한다



## SDP: 안정된 의존성 원칙(Stable-Dependencies Principle)
>안정성의 방향으로(더 안정된 쪽에) 의존하라.
* SDP가 적용된 패키지는 쉽게 변화도록 설계가 되어 있어서 **변경되리라 예상할 수 있다.**

### 안정성
안정성은 변화를 만들기 위해 필요한 작업량


**안정된 컴포넌트**
<img src="./4_component_principle/image-20191023231323243.png" alt="안정된컴포넌트" style="zoom:50%;" />

X는 안정적이다. 세 컴포넌트가 X에 의존하며 , 따라서 X는 변경하지 말아야 할 이유가 세가지나 되지 때문이다. 이 경우 X는 세 컴포넌트를 책임진다(responsible)라고 말한다. 반대로 X는 어디에도 의존하지 않으므로 X는 독립적이다.(independent)라고 말한다.

 **불안정한 컴포넌트**
<img src="./4_component_principle/image-20191023231412985.png" alt="불안정한 컴포넌트" style="zoom:50%;" />

* Y는 3개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부요인이 3가지다. 
* Y는 의존적이다.
### 안정성 지표

* fan-in: 안으로 들어오는 의존성.
* Fan-out: 밖으로 나가는 의존성.
* I(불안정성): I = Fan-out / (Fan-in + Fan-out). I=0 이면 최고로 안정된 컴포넌트라는 뜻, I=1 이면 최고로 불안정한 컴포넌트라는 뜻.


### 모든 컴퍼넌트가 안정적이어야 하는 것은 아니다.

만약 모든 패키지가 안정적이라면 시스템은 변경할 수 없게 될 것이다.
공통패키지를 이용 불안정성을 유지해서 확장가능하게 한다.

## SAP : 안정된 추상화 원칙(Stable-Abstractions Principle)

`컴포넌트는 안정된 정도만큼만 추상화되어야한다.`

안정성과 추상성 사이의 관계를 정한다.

추상클래스(인터페이스)를 통해서 추상성과 안정성 사이의 균형을 확보
패키지의 성격에 따라 적절한 추상성을 확보해야한다.

SAP와 SDP 를 결합하면 컴포넌트에 대한 DIP 와 비슷하다.
컴포넌트는 어느 부분은 추상적이면서 다른 부분은 안정적일 수 있다. 


#### 주계열
* A: 추상화 정도
* I: 불안정성



<img src="./4_component_principle/image-20191023233656788.png" alt="image-20191023233656788" style="zoom:30%;" />

* 0,0 : 안정적이고 구체적
* 1,1: 의존성이 없고(불안정적)추상적 : 쓸모없는 구역
* 1,0 & 0,1 : 주계열 , 너무 추상적이지 않고 안정적이지도 않음.